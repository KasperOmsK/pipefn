package pipefn

import (
	"fmt"
	"iter"
	"pipefn/internal/iterx"
	"sync"
)

type (
	// Pipe represents a lazily-evaluated sequence of values of type T.
	//
	// Each transformation (Map, TryMap, Flatten etc.) produces a new Pipe that wraps the previous one.
	//
	// Errors generated by faillible stages (e.g. TryMap) are sent on the shared error channel.
	//
	// A Pipe is consumed when its sequence is iterated, typically through Results,
	// Values, or ForEach. Once consumed, a Pipe cannot be reused.
	// Refer to each consuming method's documentation for details on their behavior.
	Pipe[T any] struct {
		seq    iter.Seq[T]
		errors chan PipelineError
	}

	// PipelineError represents an error that occured inside a pipeline
	PipelineError struct {
		// The item that generated the error
		Item any
		// The actual error
		Reason error
	}
)

func (pe PipelineError) Error() string {
	return fmt.Sprintf("%+v: %s", pe.Item, pe.Reason)
}

// From creates a new Pipe that produces values from the provided iter.Seq.
func From[T any](seq iter.Seq[T]) Pipe[T] {

	p := Pipe[T]{
		errors: make(chan PipelineError, 256),
	}

	p.seq = func(yield func(T) bool) {
		defer close(p.errors)
		for item := range seq {
			if !yield(item) {
				return
			}
		}
	}

	return p
}

// Results returns two iterators: one that yields the values produced by p,
// and one that yields the errors produced by p.
//
// Iterating over the values iterator consumes p. Once iteration begins,
// p cannot be reused, restarted, or iterated again.
//
// Callers must drain the errors iterator. If errors are not consumed,
// the pipeline may block when a stage attempts to send an error.
//
// Typical usage:
//
//	values, errs := p.Results()
//
//	var wg sync.WaitGroup
//	wg.Add(1)
//	go func() {
//	    defer wg.Done()
//	    for err := range errs {
//	        log.Printf("pipeline error: %v", err)
//	    }
//	}()
//
//	for v := range values {
//	    fmt.Println("value:", v)
//	}
//	wg.Wait()
//	// here, both values and errs have been fully drained.
//
// Callers that wish to consume a pipe without having to handle errors should
// use p.Values().
func (p Pipe[T]) Results() (iter.Seq[T], iter.Seq[PipelineError]) {
	// NOTE: the errors should probably be directly returned as a chan.
	return p.seq, iterx.FromChan(p.errors)
}

// Values returns the sequence of values produced by p.
//
// Values behaves like Results, except that the error sequence is consumed
// internally and discarded. This allows callers who do not care about errors
// to ignore them while still ensuring the pipe completes correctly.
//
// Iterating over the returned values sequence consumes p. Once iteration
// begins, p cannot be reused or iterated again.
//
// Typical usage:
//
//	for v := range p.Values() {
//		...
//	}
func (p Pipe[T]) Values() (values iter.Seq[T]) {
	values, errors := p.Results()
	go func() {
		for range errors {
		}
	}()
	return values
}

// ForEach consumes all values from the Pipe, invoking consumeFn for each.
//
// Errors produced by the pipe are forwarded to errorFn.
//
// ForEach returns only after all values are consumed and all errors have been handled.
func (p Pipe[T]) ForEach(consumeFn func(item T), errorFn func(err PipelineError)) {
	values, errors := p.Results()
	var errorWg sync.WaitGroup
	errorWg.Add(1)
	go func() {
		defer errorWg.Done()
		for err := range errors {
			errorFn(err)
		}
	}()
	for i := range values {
		consumeFn(i)
	}
	errorWg.Wait()
}

// Collect consumes the entire Pipe and returns two slices containing all emitted
// values and all emitted errors, respectively.
//
// Values are collected in the order they are produced by the Pipe.
// Errors are collected in the order they are emitted.
//
// Collect fully drains the Pipe; after calling it, the Pipe cannot be consumed again.
func (p Pipe[T]) Collect() ([]T, []PipelineError) {
	var (
		values []T
		errors []PipelineError
	)

	p.ForEach(func(item T) {
		values = append(values, item)
	}, func(err PipelineError) {
		errors = append(errors, err)
	})

	return values, errors
}

// CollectValues consumes the entire Pipe and returns a slice containing all
// emitted values. Errors, if any, are ignored.
//
// Values are collected in the order they are produced by the Pipe.
//
// CollectValues fully drains the Pipe; after calling it, the Pipe cannot be
// consumed again.
func (p Pipe[T]) CollectValues() []T {
	var values []T
	p.ForEach(func(item T) {
		values = append(values, item)
	}, func(err PipelineError) {})
	return values
}

// Tap modifies p so that tapFn is called for each element that passes through p.
// The tap function is called before the element is yielded.
//
// Calling Tap multiple times will chain tap functions in the order they were added.
//
// Tap panics if tapFn is nil.
func (p *Pipe[T]) Tap(tapFn func(T)) {

	if tapFn == nil {
		panic("Pipe.Tap: tapFn cannot be nil")
	}

	originalIt := p.seq
	p.seq = func(yield func(T) bool) {
		for i := range originalIt {
			tapFn(i)
			if !yield(i) {
				return
			}
		}
	}
}
